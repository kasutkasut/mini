import{d as E,e as H,r as D,y as L,R as A}from"./index-CLvkM5_n.js";function U(t){return typeof t=="string"}function _e(t,o,e){return t===void 0||U(t)?o:E({},o,{ownerState:E({},o.ownerState,e)})}function W(t,o=[]){if(t===void 0)return{};const e={};return Object.keys(t).filter(r=>r.match(/^on[A-Z]/)&&typeof t[r]=="function"&&!o.includes(r)).forEach(r=>{e[r]=t[r]}),e}function I(t){if(t===void 0)return{};const o={};return Object.keys(t).filter(e=>!(e.match(/^on[A-Z]/)&&typeof t[e]=="function")).forEach(e=>{o[e]=t[e]}),o}function we(t){const{getSlotProps:o,additionalProps:e,externalSlotProps:r,externalForwardedProps:n,className:s}=t;if(!o){const l=H(e==null?void 0:e.className,s,n==null?void 0:n.className,r==null?void 0:r.className),m=E({},e==null?void 0:e.style,n==null?void 0:n.style,r==null?void 0:r.style),a=E({},e,n,r);return l.length>0&&(a.className=l),Object.keys(m).length>0&&(a.style=m),{props:a,internalRef:void 0}}const d=W(E({},n,r)),h=I(r),y=I(n),c=o(d),f=H(c==null?void 0:c.className,e==null?void 0:e.className,s,n==null?void 0:n.className,r==null?void 0:r.className),g=E({},c==null?void 0:c.style,e==null?void 0:e.style,n==null?void 0:n.style,r==null?void 0:r.style),v=E({},c,e,y,h);return f.length>0&&(v.className=f),Object.keys(g).length>0&&(v.style=g),{props:v,internalRef:c.ref}}function Ce(t,o,e){return typeof t=="function"?t(o,e):t}const M={},R=t=>{let o;const e=new Set,r=(f,g)=>{const v=typeof f=="function"?f(o):f;if(!Object.is(v,o)){const l=o;o=g??(typeof v!="object"||v===null)?v:Object.assign({},o,v),e.forEach(m=>m(o,l))}},n=()=>o,y={setState:r,getState:n,getInitialState:()=>c,subscribe:f=>(e.add(f),()=>e.delete(f)),destroy:()=>{(M?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),e.clear()}},c=o=t(r,n,y);return y},T=t=>t?R(t):R;var x={exports:{}},F={},N={exports:{}},O={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var b=D;function J(t,o){return t===o&&(t!==0||1/t===1/o)||t!==t&&o!==o}var G=typeof Object.is=="function"?Object.is:J,Z=b.useState,B=b.useEffect,K=b.useLayoutEffect,Q=b.useDebugValue;function X(t,o){var e=o(),r=Z({inst:{value:e,getSnapshot:o}}),n=r[0].inst,s=r[1];return K(function(){n.value=e,n.getSnapshot=o,C(n)&&s({inst:n})},[t,e,o]),B(function(){return C(n)&&s({inst:n}),t(function(){C(n)&&s({inst:n})})},[t]),Q(e),e}function C(t){var o=t.getSnapshot;t=t.value;try{var e=o();return!G(t,e)}catch{return!0}}function Y(t,o){return o()}var q=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?Y:X;O.useSyncExternalStore=b.useSyncExternalStore!==void 0?b.useSyncExternalStore:q;N.exports=O;var V=N.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var w=D,ee=V;function te(t,o){return t===o&&(t!==0||1/t===1/o)||t!==t&&o!==o}var re=typeof Object.is=="function"?Object.is:te,ne=ee.useSyncExternalStore,oe=w.useRef,se=w.useEffect,ae=w.useMemo,ie=w.useDebugValue;F.useSyncExternalStoreWithSelector=function(t,o,e,r,n){var s=oe(null);if(s.current===null){var d={hasValue:!1,value:null};s.current=d}else d=s.current;s=ae(function(){function y(l){if(!c){if(c=!0,f=l,l=r(l),n!==void 0&&d.hasValue){var m=d.value;if(n(m,l))return g=m}return g=l}if(m=g,re(f,l))return m;var a=r(l);return n!==void 0&&n(m,a)?(f=l,m):(f=l,g=a)}var c=!1,f,g,v=e===void 0?null:e;return[function(){return y(o())},v===null?void 0:function(){return y(v())}]},[o,e,r,n]);var h=ne(t,s[0],s[1]);return se(function(){d.hasValue=!0,d.value=h},[h]),ie(h),h};x.exports=F;var ue=x.exports;const ce=L(ue),$={},{useDebugValue:le}=A,{useSyncExternalStoreWithSelector:de}=ce;let P=!1;const fe=t=>t;function ve(t,o=fe,e){($?"production":void 0)!=="production"&&e&&!P&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),P=!0);const r=de(t.subscribe,t.getState,t.getServerState||t.getInitialState,o,e);return le(r),r}const k=t=>{($?"production":void 0)!=="production"&&typeof t!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const o=typeof t=="function"?T(t):t,e=(r,n)=>ve(o,r,n);return Object.assign(e,o),e},me=t=>t?k(t):k,he={};function ye(t,o){let e;try{e=t()}catch{return}return{getItem:n=>{var s;const d=y=>y===null?null:JSON.parse(y,void 0),h=(s=e.getItem(n))!=null?s:null;return h instanceof Promise?h.then(d):d(h)},setItem:(n,s)=>e.setItem(n,JSON.stringify(s,void 0)),removeItem:n=>e.removeItem(n)}}const _=t=>o=>{try{const e=t(o);return e instanceof Promise?e:{then(r){return _(r)(e)},catch(r){return this}}}catch(e){return{then(r){return this},catch(r){return _(r)(e)}}}},Se=(t,o)=>(e,r,n)=>{let s={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:u=>u,version:0,merge:(u,S)=>({...S,...u}),...o},d=!1;const h=new Set,y=new Set;let c;try{c=s.getStorage()}catch{}if(!c)return t((...u)=>{console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),e(...u)},r,n);const f=_(s.serialize),g=()=>{const u=s.partialize({...r()});let S;const i=f({state:u,version:s.version}).then(p=>c.setItem(s.name,p)).catch(p=>{S=p});if(S)throw S;return i},v=n.setState;n.setState=(u,S)=>{v(u,S),g()};const l=t((...u)=>{e(...u),g()},r,n);let m;const a=()=>{var u;if(!c)return;d=!1,h.forEach(i=>i(r()));const S=((u=s.onRehydrateStorage)==null?void 0:u.call(s,r()))||void 0;return _(c.getItem.bind(c))(s.name).then(i=>{if(i)return s.deserialize(i)}).then(i=>{if(i)if(typeof i.version=="number"&&i.version!==s.version){if(s.migrate)return s.migrate(i.state,i.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return i.state}).then(i=>{var p;return m=s.merge(i,(p=r())!=null?p:l),e(m,!0),g()}).then(()=>{S==null||S(m,void 0),d=!0,y.forEach(i=>i(m))}).catch(i=>{S==null||S(void 0,i)})};return n.persist={setOptions:u=>{s={...s,...u},u.getStorage&&(c=u.getStorage())},clearStorage:()=>{c==null||c.removeItem(s.name)},getOptions:()=>s,rehydrate:()=>a(),hasHydrated:()=>d,onHydrate:u=>(h.add(u),()=>{h.delete(u)}),onFinishHydration:u=>(y.add(u),()=>{y.delete(u)})},a(),m||l},ge=(t,o)=>(e,r,n)=>{let s={storage:ye(()=>localStorage),partialize:a=>a,version:0,merge:(a,u)=>({...u,...a}),...o},d=!1;const h=new Set,y=new Set;let c=s.storage;if(!c)return t((...a)=>{console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),e(...a)},r,n);const f=()=>{const a=s.partialize({...r()});return c.setItem(s.name,{state:a,version:s.version})},g=n.setState;n.setState=(a,u)=>{g(a,u),f()};const v=t((...a)=>{e(...a),f()},r,n);n.getInitialState=()=>v;let l;const m=()=>{var a,u;if(!c)return;d=!1,h.forEach(i=>{var p;return i((p=r())!=null?p:v)});const S=((u=s.onRehydrateStorage)==null?void 0:u.call(s,(a=r())!=null?a:v))||void 0;return _(c.getItem.bind(c))(s.name).then(i=>{if(i)if(typeof i.version=="number"&&i.version!==s.version){if(s.migrate)return[!0,s.migrate(i.state,i.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,i.state];return[!1,void 0]}).then(i=>{var p;const[j,z]=i;if(l=s.merge(z,(p=r())!=null?p:v),e(l,!0),j)return f()}).then(()=>{S==null||S(l,void 0),l=r(),d=!0,y.forEach(i=>i(l))}).catch(i=>{S==null||S(void 0,i)})};return n.persist={setOptions:a=>{s={...s,...a},a.storage&&(c=a.storage)},clearStorage:()=>{c==null||c.removeItem(s.name)},getOptions:()=>s,rehydrate:()=>m(),hasHydrated:()=>d,onHydrate:a=>(h.add(a),()=>{h.delete(a)}),onFinishHydration:a=>(y.add(a),()=>{y.delete(a)})},s.skipHydration||m(),l||v},pe=(t,o)=>"getStorage"in o||"serialize"in o||"deserialize"in o?((he?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),Se(t,o)):ge(t,o),Ee=pe,He=me(Ee((t,o)=>({user:null,chatHistory:{},chatCount:0,isPremium:!1,characterStats:{},initCharacterStats:e=>{const r={};Object.keys(e).forEach(n=>{r[n]={likes:0,favorites:0,isLiked:!1,isFavorited:!1,createdAt:new Date(Date.now()-Math.random()*90*24*60*60*1e3)}}),t({characterStats:r})},toggleLike:e=>{t(r=>{const n=r.characterStats[e];return n?{characterStats:{...r.characterStats,[e]:{...n,likes:n.likes+(n.isLiked?-1:1),isLiked:!n.isLiked}}}:r})},toggleFavorite:e=>{t(r=>{const n=r.characterStats[e];return n?{characterStats:{...r.characterStats,[e]:{...n,favorites:n.favorites+(n.isFavorited?-1:1),isFavorited:!n.isFavorited}}}:r})},getCharacterStats:e=>o().characterStats[e],increaseChatCount:()=>t(e=>({chatCount:e.chatCount+1})),setPremium:e=>t({isPremium:e}),resetChatCount:()=>t({chatCount:0}),canChat:()=>{const{chatCount:e,isPremium:r}=o();return r||e<10},remainingFreeChats:()=>{const{chatCount:e}=o();return Math.max(0,10-e)},setUser:e=>t({user:e,isPremium:!1}),logout:()=>t({user:null,isPremium:!1,chatCount:0,chatHistory:{}}),addChatMessage:(e,r)=>{const n=new Date().toISOString();t(s=>{var d;return{chatHistory:{...s.chatHistory,[e]:{messages:[...((d=s.chatHistory[e])==null?void 0:d.messages)||[],{...r,timestamp:n}]}}}})},clearChatHistory:e=>{t(r=>{const n={...r.chatHistory};return delete n[e],{chatHistory:n}})},clearAllChatHistory:()=>{t({chatHistory:{}})},getChatHistory:e=>{var r;return((r=o().chatHistory[e])==null?void 0:r.messages)||[]}}),{name:"user-storage",version:1}));export{_e as a,W as e,U as i,we as m,Ce as r,He as u};
//# sourceMappingURL=userStore-DtecM2vn.js.map
